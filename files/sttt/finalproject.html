<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>CSci 1901 Homepage</title>
</head>
<body bgcolor="ivory">
<pre><span style="font-weight: bold;">CSci 1901 Spring 2004 Final Project</span><br
 style="font-weight: bold;"><br style="font-weight: bold;"><span
 style="font-weight: bold;">*** Tournament Entry Date:  Wednesday, May 5, 2004 at midnight</span><br
 style="font-weight: bold;"><span style="font-weight: bold;">*** Final Due Date:  Monday, May 10, 2004 at noon</span><br
 style="font-weight: bold;"><span style="font-weight: bold;"><br>Files You will need:<br>	<a
 href="files/gdraw.stk">gdraw.stk</a> - </span> Graphics package used by game code<br>	<span
 style="font-weight: bold;"><a href="files/sttt.scm">sttt</a><a
 href="files/sttt.scm">.scm</a>  - </span>Referee code <br>	<br><br
 style="font-weight: bold;"><br style="font-weight: bold;"><span
 style="font-weight: bold;">Purpose</span><br><br>The goal of this assignment is for you to write code to play one<br>player's part in a game called "SUPER-TIC-TAC-TOE".  More specifically, <br>you will need to write an AI (Artificial Intelligence) player procedure <br>that will return a valid move when called by the "referee" code that <br>runs the game.  The referee code is already written for you.  So, your <br>AI will just need to make a strategic move each time it is called.  <br><br><br
 style="font-weight: bold;"><span style="font-weight: bold;">General Description</span><br><br>You will be writing an intelligent computer game player that will play<br>an enhanced version of tic-tac-toe called SUPER-TIC-TAC-TOE against a <br>human (interactive) player or another computer (AI) player.  What you <br>will be writing is analogous to the well-publicized computer chess <br>players that are used to compete against human players, although not on <br>the same scale, and of course, for a simpler game.  All of the code <br>necessary to "referee" the game--prompting the players (whether human <br>or computer), determining if a player won or made an illegal move, and <br>displaying the board--is already written for you and available in the <br>document "sttt.scm".  The referee code makes use of a graphics package<br>called "gdraw.stk" which you can download and place in the same directory<br>as sttt.scm.<br><br>The referee code in "sttt.scm" will continually call your computer<br>player for a move until a win occurs by one of the players.  There<br>should be no other interface or restrictions with your game player<br>module.  With the referee already written, you can concentrate on<br>writing the heuristics (or "smarts") needed to make intelligent moves<br>when your AI is prompted by the referee to return a move.<br><br>The hope is that you will be able to apply the rules of the game<br>together with a strategy to produce a computer player that can win<br>against a variety of human and computer opponents.<br><br><br><span
 style="font-weight: bold;">Description and Rules</span><br><br>SUPER-TIC-TAC-TOE is played by two players, either or both of which can <br>be interactive (person) or computer (AI) players.  The game board,<br>which is initially empty, is a standard 3-by-3 tic-tac-toe board at the<br>top level.  But, it is enhanced by the fact that each square of the game <br>board is itself another tic-tac-toe board of dimension 3-by-3.  We will <br>refer to the top level game board as the "big board" and the individual <br>nested boards (of which there are nine total) as "little boards."<br><br>The players take alternate turns placing TWO X's (or TWO O's depending<br>on which player started) in open locations in any of the little boards.  <br>This is different from traditional tic-tac-toe because a turn consists of <br>making TWO moves rather than one.  It is not possible to place a symbol <br>in a big board square directly.  A big board square is awarded to the <br>player who wins the little board tic-tac-toe game nested within the big <br>board square.  This brings us to the goal of the game:  to win three big <br>board squares in a row (vertically, horizontally or diagonally) by <br>winning the nested tic-tac-toe games within those big board squares.<br><br>Note that there are 81 little board squares (see diagram below).  In the <br>rare case where there is only one remaining open little board square <br>anywhere on the board, the last turn will consist of only a single move <br>due to the odd number of little board squares.  Once a big board square <br>has been awarded to a player because the little board game within in it <br>has been won, no additional moves will register on the little board <br>corresponding to the awarded big board square.<br><br>Board Diagrams:<br><br>(a) Empty Board  <br>    (* indicates an empty square)<br><br>    ***|***|***<br>    ***|***|***<br>    ***|***|***<br>    -----------<br>    ***|***|***<br>    ***|***|***<br>    ***|***|***<br>    -----------<br>    ***|***|***<br>    ***|***|***<br>    ***|***|***<br><br>(b) Game Board Showing Indices and Order of Big Board Squares<br><br>       |   |<br>     1 | 2 | 3<br>       |   |<br>    -----------<br>       |   |<br>     4 | 5 | 6<br>       |   |<br>    -----------<br>       |   |<br>     7 | 8 | 9 <br>       |   |  <br><br>(c) Game Board Showing Indices and Order of Little Board Squares<br>    (big board indices echo the little board index convention)<br><br>    123|123|123<br>    456|456|456<br>    789|789|789<br>    -----------<br>    123|123|123<br>    456|456|456<br>    789|789|789<br>    -----------<br>    123|123|123<br>    456|456|456<br>    789|789|789<br><br>(d) Partially Played Game Board Configuration<br>    (the lower right square was awarded to X who won the little game within)<br><br>      O|XXO| X<br>    XXO|   | X<br>    OXX|OOX|OOX<br>    -----------<br>       |   |<br>       |   | X<br>    OXO|   |O<br>    -----------<br>       |   |\ /<br>       |   | X<br>       |   |/ \<br><br><br>A Rules Summary appears below.  These are enforced by the referee.<br>Erroneous moves are not registered.  For interactive play, a turn<br>continues until legal placements are made.  For a computer player,<br>illegal placements are ignored, so illegal placements result in that<br>placement opportunity being forfeited.<br><br>1.  A player is either X or O depending on whether he is the first or<br>    second player to play.<br>2.  Two placements are made at each turn (except possibly in the ending <br>    case described above).<br>3.  A player cannot play over a little board square that is already<br>    occupied.<br>4.  A player cannot play in a big board square directly.  Play is limited<br>    to selecting little board squares.<br>5.  A player acquires a big board square by winning the little board <br>    game within it.<br>6.  Once a big board square is won, no more play may will register within <br>    the little board squares within it--even if some of the little board <br>    squares were left open at the time that little board game was won.<br>7.  These placements are ignored and result in a computer player <br>    forfeiting that particular placement opportunity.<br>    - playing on a already played square<br>    - playing in a little board that has already been won by someone<br>    - playing outside the board<br>    - returning an ill-formatted move (see format for a move below)<br><br><br><span
 style="font-weight: bold;">What Your Computer Player is Given and What It Should Produce</span><br><br>You will need to write a single AI procedure (that may contain<br>local state and local procedures).  The comments in the referee code<br>will show how to make the name of your AI known to the referee.<br>The AI must accept two parameters:  the current game board and which<br>player ('x or 'o) it is (so your AI will always know which player it <br>is).  The AI will return its current move which normally consists of <br>placement of two X's or O's on the board.  <br><br>The formats for the board and move structures are described below.  <br>It is important that your AI strictly adheres to these data structures <br>and that it generates legal moves; otherwise the referee will not be <br>able to recognize your AI's intended moves.  Moves that cannot be <br>recognized either because they are formatted incorrectly or because <br>they are illegal will not be entered by the referee.  Thus such <br>placements are effectively forfeited.<br><br>  * The "board" data structure:  When the referee code calls your<br>    AI, it sends current the game board.  The game board received is a <br>    COPY of the actual game board.  So, any changes your AI makes to <br>    this game board copy should NOT affect the real game board.  The <br>    game board data structure is a headed list representing the big <br>    board.  The header symbol is 'big.  The list continues with each <br>    of the nine little boards in the order as shown in Board Diagram <br>    (b) above.  The little boards are also headed lists.  The little <br>    boards are headed with the symbol 'little.  Similarly they <br>    continue with the contents of their squares in the same order as <br>    shown in Board Diagram (c) above.  The individual square contents <br>    will be one of the following:<br><br>      () - the square is empty<br>      'x - the square is occupied by player X<br>      'o - the square is occupied by player O<br><br>    For example, the game board representation before anyone has played <br>    will be empty:<br><br>        ('big ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>        )<br><br>    Assuming the first player puts his X's in <br><br>      - the upper left square of the little board in the upper left <br>        of the big board <br><br>     and<br><br>      - the center square of the little board in the center square<br>        of the big board,<br><br>    the game board representation will look like this:<br><br>        ('big ('little 'x () () () () () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () 'x () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>              ('little () () () () () () () () ())<br>        )<br>   <br>  * The player symbol, sent as the second parameter to your AI after <br>    the board, is simply one of 'x or 'o.<br><br>  * The "move" structure.  This is what is returned by your AI.  It<br>    it is a simple list of two moves each of which is represented by<br>    a pair of indices with the big board index first, and the little<br>    board index second.  The general format is:<br><br>        ((big-board-index . little-board-index)<br>         (big-board-index . little-board-index)<br>        )<br><br>    In the rare case that only one move is to be made, either of the<br>    pairs can be replaced with ().<br><br>    Three examples<br><br>    (1)  To represent Player X's two move placements shown in the<br>    game board representation just above we have the following:<br><br>        ((1 . 1) (5 . 5))<br><br>    (2)  To represent a player's move with placements in<br><br>      - the center square of the upper left little board<br><br>      and<br>      <br>      - the lower right square of the lower left little board<br><br>    we have the following:<br><br>        ((1 . 5) (7 . 9))<br><br>    (3)  To represent the RARE move consisting only of one placement <br>    (say, in the lower right square of the lower right little board) <br>    the actual placement may appear either first or second relative <br>    to the null placement:<br><br>        ((9 . 9) ())<br><br>    or the alternative:<br><br>        (() (9 . 9))<br><br><br
 style="font-weight: bold;"><span style="font-weight: bold;">Writing Your Code</span><br><br>To do this project you do NOT need to understand the referee code in<br>'sttt.scm'.  Your job is to write just an AI player.  Your AI will be <br>called by, but be independent of, the referee code.  This means your <br>AI will not have access to any of the referee code's local procedures <br>or local data, and vice versa.  Attempt to modify the referee's game<br>board directly with your AI will be considered tampering and will <br>result in forfeiture of your game.  If you think it would be useful for <br>your code to use some of the referee code's local procedures, you are <br>welcome to copy them, modify them as needed, and use them as local <br>procedures in your AI.  However, if you do this you should:<br><br>     (i)  note the source of the code in your comments within the<br>          procedures using code obtained elsewhere<br>     (ii) make re-used code local to (i.e., nested inside) your AI<br><br>You are also free to use any of the code from the text, from the class <br>web page, or from your own previous assignments.  But, again, for any <br>code you reuse you must include comments indicating where the code <br>was obtained.<br><br>Following is an outline of an AI called my-ai that you can use as a <br>template for setting up your own AI.  There is not much of any real <br>code here, but this should give you a framework under which to start.<br><br>    ; a sample AI player to serve as a general template <br><br>    (define (make-ai)<br><br>      ; local state info, if any, might go here <br>      ; may include last move info, strategy info, previous board state<br><br>        (define (AI board who)  ; AI is entry point for our AI<br><br>            ; code to compute my move and update local state as needed<br>            ; this procedure returns a list of two moves representing<br>            ; the intended placements of my X/O's on the board<br><br>        )<br><br>        AI    ; AI (which operates in the environment referred to as the<br>              ; local state above) is returned from a call to make-ai<br>    )<br><br>    (define my-ai (make-ai))    ; create my-ai as AI in local state<br><br><br
 style="font-weight: bold;"><span style="font-weight: bold;">Running the Game (Referee)</span><br><br>After loading the sttt.scm code into STk, a new window with the game <br>board will pop up.  Note that the graphical user interface of the referee <br>requires STk to run.  The referee will not run, for example, under snow <br>or MIT Scheme.<br><br>The game mode can be for 2 human players, 2 computer players, or 1 of <br>each with the computer being either the first (X) or second (O) player.  <br>The X player always goes first.  Each of the three modes is described <br>below.  <br><br>    * 2 human players:  At the very last line of the sttt.scm code, call<br>        (start!) with no parameters or with two parameters that are the<br>        symbol 'human like this:  (start! 'human 'human).<br><br>    * 2 computer players:  Call (start!) with the names of the two<br>        AI procedures.  For example, to run your own AI procedure, called<br>        my-ai against itself, the last line of the sttt.scm code will be<br>        (start! my-ai my-ai).  <br><br>    * 1 human, 1 computer player:  Call (start!) with 'human for one of<br>        the parameters and the name of the AI procedure for the other<br>        parameter.  The first parameter passed to (start!) will always <br>        be the X player (the player who starts) and the second parameter<br>        passed to (start!) will be the O player (the player who goes<br>        second).  To play your own player against the built-in random<br>        player for testing, the last line of the sttt.scm code will be<br>        (start! my-ai random-ai).  This will have my-ai be the X player<br>        and start the play.  (start! random-ai my-ai) will have my-ai be <br>        the O player and go second.<br><br><br><span
 style="font-weight: bold;">Collaboration and working in groups</span><br><br>You are permitted and encouraged to work in groups of 2 on this<br>assignment. Sorry, no groups of 3 or more.<br><br>Please see the comments in the assignment guidelines file about the<br>amount of collaboration allowed, regardless of whether or not you are<br>working in a group.  Remember that misconduct such as copying code<br>(from anyone else if you are working individually, from anyone outside<br>your group if you are working in a group) or giving others copies of<br>your code is a grave situation and will have serious repercussions.<br><br><br>Grading <br><br>15 points -  your AI module makes all legal moves without crashing <br>             until the game is over (win or lose)<br>15 points -  organization and apparent effort<br>20 points -  performance against benchmark computer players in a <br>             variety of trials (for example, against a random player,<br>             against a moderately good offensive player, etc.)<br><br>Players must return moves in a timely fashion to avoid delay-of-game<br>forfeiture.  As a rough rule of thumb, your next move should take <br>no more than 1 real-time second to compute and generate.  So, basically<br>there should be no noticeable delay.  Accordingly, you are encouraged <br>emphasize strategy as opposed spending lots of computer time on <br>generating a game tree of possible moves and responses.  Also, players <br>that attempt to subvert the referee program will be disqualified.<br><br><br><span
 style="font-weight: bold;">Optional Tournament Bonus Points</span><br><br>You are strongly encouraged to enter your program into the class <br>tournament. Programs that do well in the tournament will earn bonus <br>points.  You cannot be penalized for entering the tournament.  But,<br>in order to enter, your AI must be capable of making legal moves<br>without crashing.<br><br>In order to enter the tournament, you must submit your entry by <br>midnight on Wednesday, May 5, 2004.  Your entry must work correctly.  <br>Any program that crashes, takes an inordinate amount of time to <br>generate moves, or in any other way makes it difficult or impossible <br>to complete a game in a timely fashion will not be allowed in the <br>tournament.  <br><br>Finalists will for each section will be determined in a round-robin <br>qualifier by section.  The top finishers from round-robin play will <br>move on to a championship tournament in lecture on Friday, May 7,<br>2004.<br><br>If you enter the tournament you can continue to work on your program for<br>the non-tournament part of the assignment and turn in another version<br>by the general due date (see top of this writeup).<br><br>Bonus points will be awarded as follows:<br><br>10 points for the top FOUR finishers in the local (section) round-robin <br>   tournament <br>10 points for the semi-finalists (top FOUR) in the all-class tournament<br>10 points for the finalists (top TWO) in the all-class tournament<br>10 points for being the overall winner in the all-class tournament<br><br>If you work in a group of 2, *both* players will get the same bonus <br>points.<br><br><br><span
 style="font-weight: bold;">Submitting the program</span><br><br>Please submit your program before the due date.  Please send the program <br>as a *single plain text* document using the regular assignment submission<br>method (see Assignment Submission Method link on class web page).<br>Include any code you use from the text, class web page or from any of<br>your previous assignments.  If you are working in a group, please send<br>just one program for the group.  <br><br>Also fill in the following submission form, and attach it at the<br>*front* of your program. This form *must* be filled in correctly and<br>attached to your program. Please be careful to fill this in correctly.<br><br>;<br>; NAME(S) and ID#(S)<br>;<br>;<br>;<br>; DISCUSSION TIME:<br>;<br>; <br>;<br>; MACHINE NAME AND TYPE THAT PROGRAM WAS LAST TESTED ON:<br>; <br>;<br>;<br>; PLEASE CHECK ONE OF THE FOLLOWING:<br>;     <br>;  ____   Tournament only (I (we) will submit other code for the <br>;            regular (i.e., non-tournament) part)<br>;     <br>;  ____   Tournament + regular assignment (please use this code for both<br>;            the tournament and the regular (i.e., non-tournament) part)<br>; <br>;  ____   Regular (i.e., non-tournament) only     <br>;<br>; ---------------------------<br><br><br><br><span
 style="font-weight: bold;">Advice On How to Proceed</span><br><br>Work with a partner on this project, particularly if you plan to<br>earn bonus points.<br><br>Begin working on this or at least thinking about it soon.  While at <br>the time of posting some information needed to implement the player <br>has yet to be covered, you can begin working on some winning strategies<br>by playing the game yourself.  Then, you can implement some of those<br>strategies when your are ready to begin writing code.<br><br>Start now, by downloading the referee code, and loading it into STk.  <br>The game should automatically start in a separate window upon loading,<br>but make sure you have already downloaded gdraw.stk and have it in <br>the same directory as sttt.scm.  Try playing the game yourself, or<br>maybe play against the included random player.  <br><br>Before spending a lot of time developing an advanced strategy,<br>implement and test a simple strategy.  This will ensure that you have<br>at least something working to turn in if you run into unexpected<br>problems on your advanced strategy.<br><br>If you are developing your program at home, make sure your assignment<br>works under STk Scheme on an ITlabs machine.  Check this far enough in<br>advance of the due date that you can correct any problems that occur.<br><br>Develop your code using the good programming practices mentioned in<br>class.  This will be a longer assignment than past exercises, and so<br>pay attention to coding techniques that make your program easy to<br>develop, understand, and debug.<br><br>When defining procedures, make them internal to your AI.<br>This will help you avoid any potential name collision problems.<br><br>Budget time near the due date for testing your program.  Do not expect<br>to finish your program the day it's due, test it quickly, and then<br>submit it.<br><br>All programs must run under STk on one of the machines in the<br>IT lab.  If you develop your program on another machine it is your<br>responsibility, before submitting your program, to ensure that it runs<br>on one of the lab machines.<br><br>We wish you the best, and may the best program win!!</pre>
    <p align="center"> 
    <img src="images/divider.gif" width="497" height="9" alt="-------------------------------------------------"> 
    <br />
    CSci 1901, Spring 2004
    </p> 

</body>
</html>
